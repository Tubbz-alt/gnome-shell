From: =?utf-8?b?Ik1hcmNvIFRyZXZpc2FuIChUcmV2acOxbyki?= <mail@3v1n0.net>
Date: Tue, 17 Apr 2018 04:43:34 -0500
Subject: st-texture-cache: Don't add NULL textures to cache

This might cause a crash when cleaning up the cache as the hash table has
cogl_object_unref as DestroyNotify function but that assumes that
the passed object is a valid CoglObject.

st-texture-cache: Save cairo surfaces to a different map

The default keyed_surface is meant to handle CoglTextures thus we can't
add cairo surfaces to it, as the DestroyNotify function won't handle them.

Then the quicker way is to just add another Hash table for handling
such types of textures, with proper destroy function.

Forwarded: yes, https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/79
Bug-GNOME: https://gitlab.gnome.org/GNOME/gnome-shell/issues/210
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/gnome-shell/+bug/1754445
---
 src/st/st-texture-cache.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/src/st/st-texture-cache.c b/src/st/st-texture-cache.c
index 13b019e..168473b 100644
--- a/src/st/st-texture-cache.c
+++ b/src/st/st-texture-cache.c
@@ -37,6 +37,7 @@ struct _StTextureCachePrivate
 
   /* Things that were loaded with a cache policy != NONE */
   GHashTable *keyed_cache; /* char * -> CoglTexture* */
+  GHashTable *surfaces_keyed_cache; /* char * -> cairo_surface_t* */
 
   /* Presently this is used to de-duplicate requests for GIcons and async URIs. */
   GHashTable *outstanding_requests; /* char * -> AsyncTextureLoadData * */
@@ -145,6 +146,10 @@ st_texture_cache_init (StTextureCache *self)
 
   self->priv->keyed_cache = g_hash_table_new_full (g_str_hash, g_str_equal,
                                                    g_free, cogl_object_unref);
+  self->priv->surfaces_keyed_cache = g_hash_table_new_full (g_str_hash,
+                                                            g_str_equal,
+                                                            g_free,
+                                                            (GDestroyNotify) cairo_surface_destroy);
   self->priv->outstanding_requests = g_hash_table_new_full (g_str_hash, g_str_equal,
                                                             g_free, NULL);
   self->priv->file_monitors = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal,
@@ -166,6 +171,7 @@ st_texture_cache_dispose (GObject *object)
     }
 
   g_clear_pointer (&self->priv->keyed_cache, g_hash_table_destroy);
+  g_clear_pointer (&self->priv->surfaces_keyed_cache, g_hash_table_destroy);
   g_clear_pointer (&self->priv->outstanding_requests, g_hash_table_destroy);
   g_clear_pointer (&self->priv->file_monitors, g_hash_table_destroy);
 
@@ -520,6 +526,8 @@ finish_texture_load (AsyncTextureLoadData *data,
     goto out;
 
   texdata = pixbuf_to_cogl_texture (pixbuf);
+  if (!texdata)
+    goto out;
 
   if (data->policy != ST_TEXTURE_CACHE_POLICY_NONE)
     {
@@ -1295,6 +1303,9 @@ st_texture_cache_load_file_sync_to_cogl_texture (StTextureCache *cache,
       texdata = pixbuf_to_cogl_texture (pixbuf);
       g_object_unref (pixbuf);
 
+      if (!texdata)
+        goto out;
+
       if (policy == ST_TEXTURE_CACHE_POLICY_FOREVER)
         {
           cogl_object_ref (texdata);
@@ -1326,7 +1337,7 @@ st_texture_cache_load_file_sync_to_cairo_surface (StTextureCache        *cache,
 
   key = g_strdup_printf (CACHE_PREFIX_FILE_FOR_CAIRO "%u", g_file_hash (file));
 
-  surface = g_hash_table_lookup (cache->priv->keyed_cache, key);
+  surface = g_hash_table_lookup (cache->priv->surfaces_keyed_cache, key);
 
   if (surface == NULL)
     {
@@ -1340,7 +1351,8 @@ st_texture_cache_load_file_sync_to_cairo_surface (StTextureCache        *cache,
       if (policy == ST_TEXTURE_CACHE_POLICY_FOREVER)
         {
           cairo_surface_reference (surface);
-          g_hash_table_insert (cache->priv->keyed_cache, g_strdup (key), surface);
+          g_hash_table_insert (cache->priv->surfaces_keyed_cache,
+                               g_strdup (key), surface);
         }
     }
   else
